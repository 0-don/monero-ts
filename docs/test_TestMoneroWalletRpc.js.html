<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: test/TestMoneroWalletRpc.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: test/TestMoneroWalletRpc.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const assert = require("assert");
const TestUtils = require("./utils/TestUtils");
const TestMoneroWalletCommon = require("./TestMoneroWalletCommon");
const TestMoneroWalletFull = require("./TestMoneroWalletFull");
const monerojs = require("../../index");
const MoneroError = monerojs.MoneroError;
const GenUtils = monerojs.GenUtils;
const MoneroWalletConfig = monerojs.MoneroWalletConfig;
const MoneroUtils = monerojs.MoneroUtils;
const MoneroAccountTag = monerojs.MoneroAccountTag;

/**
 * Tests the Monero Wallet RPC client and server.
 */
class TestMoneroWalletRpc extends TestMoneroWalletCommon {
  
  constructor(testConfig) {
    super(testConfig);
  }
  
  async beforeAll() {
    await super.beforeAll();
    
    // if full tests ran, wait for full wallet's pool txs to confirm
    if (TestMoneroWalletFull.FULL_TESTS_RUN) {
      let walletFull = await TestUtils.getWalletFull();
      await TestUtils.WALLET_TX_TRACKER.waitForWalletTxsToClearPool(walletFull);
      await walletFull.close(true);
    }
  }
  
  async beforeEach(currentTest) {
    await super.beforeEach(currentTest);
  }
  
  async afterAll() {
    await super.afterAll();
    for (let portOffset of Object.keys(TestUtils.WALLET_PORT_OFFSETS)) { // TODO: this breaks encapsulation, use MoneroWalletRpcManager
      console.error("WARNING: Wallet RPC process on port " + (TestUtils.WALLET_RPC_PORT_START + Number(portOffset)) + " was not stopped after all tests, stopping");
      await TestUtils.stopWalletRpcProcess(TestUtils.WALLET_PORT_OFFSETS[portOffset]);
    }
  }
  
  async afterEach(currentTest) {
    await super.afterEach(currentTest);
  }
  
  async getTestWallet() {
    return TestUtils.getWalletRpc();
  }
  
  async getTestDaemon() {
    return TestUtils.getDaemonRpc();
  }
  
  async openWallet(config) {
    
    // assign defaults
    config = new MoneroWalletConfig(config);
    if (!config.getPassword()) config.setPassword(TestUtils.WALLET_PASSWORD);
    
    // create client connected to internal monero-wallet-rpc executable
    let wallet = await TestUtils.startWalletRpcProcess();
    
    // open wallet
    try {
      await wallet.openWallet(config);
      if (config.getServerUri() === "") wallet.setDaemonConnection(""); // serverUri "" denotes offline wallet for tests
      else await wallet.startSyncing(TestUtils.SYNC_PERIOD_IN_MS);
      return wallet;
    } catch (err) {
      await TestUtils.stopWalletRpcProcess(wallet);
      throw err;
    }
  }
  
  async createWallet(config) {
    
    // assign defaults
    config = new MoneroWalletConfig(config);
    let random = !config.getMnemonic() &amp;&amp; !config.getPrimaryAddress();
    if (!config.getPath()) config.setPath(GenUtils.getUUID());
    if (!config.getPassword()) config.setPassword(TestUtils.WALLET_PASSWORD);
    if (!config.getRestoreHeight() &amp;&amp; !random) config.setRestoreHeight(0);
    
    // create client connected to internal monero-wallet-rpc executable
    let wallet = await TestUtils.startWalletRpcProcess();
    
    // create wallet
    try {
      await wallet.createWallet(config);
      if (config.getServerUri() === "") wallet.setDaemonConnection(""); // serverUri "" denotes offline wallet for tests
      else await wallet.startSyncing(TestUtils.SYNC_PERIOD_IN_MS);
      return wallet;
    } catch (err) {
      await TestUtils.stopWalletRpcProcess(wallet);
      throw err;
    }
  }
  
  async closeWallet(wallet, save) {
    await wallet.close(save);
    await TestUtils.stopWalletRpcProcess(wallet);
  }
  
  async getMnemonicLanguages() {
    return await this.wallet.getMnemonicLanguages();
  }
  
  runTests() {
    let that = this;
    let testConfig = this.testConfig;
    describe("TEST MONERO WALLET RPC", function() {
      
      // register handlers to run before and after tests
      before(async function() { await that.beforeAll(); });
      beforeEach(async function() { await that.beforeEach(this.currentTest); });
      after(async function() { await that.afterAll(); });
      afterEach(async function() { await that.afterEach(this.currentTest); });
      
      // run tests specific to wallet rpc
      that._testWalletRpc(testConfig);
      
      // run common tests
      that.runCommonTests(testConfig);
    });
  }
  
  // ---------------------------------- PRIVATE -------------------------------
  
  // rpc-specific tx test
  async _testTxWallet(tx, ctx) {
    ctx = Object.assign({}, ctx);
    
    // run common tests
    await super._testTxWallet(tx, ctx);
  }
  
  // rpc-specific out-of-range subaddress test
  async _testGetSubaddressAddressOutOfRange() {
    let accounts = await this.wallet.getAccounts(true);
    let accountIdx = accounts.length - 1;
    let subaddressIdx = accounts[accountIdx].getSubaddresses().length;
    let address = await this.wallet.getAddress(accountIdx, subaddressIdx);
    assert.equal(address, undefined);
  }
  
  _testInvalidAddressError(err) {
    super._testInvalidAddressError(err);
    assert.equal(-2, err.getCode());
  }
  
  _testInvalidTxHashError(err) {
    super._testInvalidTxHashError(err);
    assert.equal(-8, err.getCode());
  }
  
  _testInvalidTxKeyError(err) {
    super._testInvalidTxKeyError(err);
    assert.equal(-25, err.getCode());
  }
  
  _testInvalidSignatureError(err) {
    super._testInvalidSignatureError(err);
    assert.equal(-1, err.getCode());
  }
  
  _testNoSubaddressError(err) {
    super._testNoSubaddressError(err);
    assert.equal(-1, err.getCode());
  }
  
  _testSignatureHeaderCheckError(err) {
    super._testSignatureHeaderCheckError(err);
    assert.equal(-1, err.getCode());
  }
  
  _testWalletRpc(testConfig) {
    let that = this;
    describe("Tests specific to RPC wallet", function() {
      
      // ---------------------------- BEGIN TESTS ---------------------------------
      
      if (testConfig.testNonRelays)
      it("Can create a wallet with a randomly generated mnemonic", async function() {
        
        // create random wallet with defaults
        let path = GenUtils.getUUID();
        let wallet = await that.createWallet({path: path});
        let mnemonic = await wallet.getMnemonic();
        MoneroUtils.validateMnemonic(mnemonic);
        assert.notEqual(mnemonic, TestUtils.MNEMONIC);
        MoneroUtils.validateAddress(await wallet.getPrimaryAddress(), TestUtils.NETWORK_TYPE);
        await wallet.sync();  // very quick because restore height is chain height
        await that.closeWallet(wallet);

        // create random wallet with non defaults
        path = GenUtils.getUUID();
        wallet = await that.createWallet({path: path, language: "Spanish"});
        MoneroUtils.validateMnemonic(await wallet.getMnemonic());
        assert.notEqual(await wallet.getMnemonic(), mnemonic);
        mnemonic = await wallet.getMnemonic();
        MoneroUtils.validateAddress(await wallet.getPrimaryAddress(), TestUtils.NETWORK_TYPE);
        
        // attempt to create wallet which already exists
        try {
          await that.createWallet({path: path, language: "Spanish"});
        } catch (e) {
          assert.equal(e.message, "Wallet already exists: " + path);
          assert.equal(-21, e.getCode())
          assert.equal(mnemonic, await wallet.getMnemonic());
        }
        await that.closeWallet(wallet);
      });
      
      if (testConfig.testNonRelays)
      it("Can create a RPC wallet from a mnemonic phrase", async function() {
        
        // create wallet with mnemonic and defaults
        let path = GenUtils.getUUID();
        let wallet = await that.createWallet({path: path, password: TestUtils.WALLET_PASSWORD, mnemonic: TestUtils.MNEMONIC, restoreHeight: TestUtils.FIRST_RECEIVE_HEIGHT});
        assert.equal(await wallet.getMnemonic(), TestUtils.MNEMONIC);
        assert.equal(await wallet.getPrimaryAddress(), TestUtils.ADDRESS);
        await wallet.sync();
        assert.equal(await wallet.getHeight(), await that.daemon.getHeight());
        let txs = await wallet.getTxs();
        assert(txs.length > 0); // wallet is used
        assert.equal(txs[0].getHeight(), TestUtils.FIRST_RECEIVE_HEIGHT);
        await that.closeWallet(wallet);
        
        // create wallet with non-defaults
        path = GenUtils.getUUID();
        wallet = await that.createWallet({path: path, password: TestUtils.WALLET_PASSWORD, mnemonic: TestUtils.MNEMONIC, restoreHeight: TestUtils.FIRST_RECEIVE_HEIGHT, language: "German", seedOffset: "my offset!", saveCurrent: false});
        MoneroUtils.validateMnemonic(await wallet.getMnemonic());
        assert.notEqual(await wallet.getMnemonic(), TestUtils.MNEMONIC);  // mnemonic is different because of offset
        assert.notEqual(await wallet.getPrimaryAddress(), TestUtils.ADDRESS);
        await that.closeWallet(wallet);
      });
      
      if (testConfig.testNonRelays)
      it("Can open wallets", async function() {
      
        // create names of test wallets
        let numTestWallets = 3;
        let names = [];
        for (let i = 0; i &lt; numTestWallets; i++) names.push(GenUtils.getUUID());
        
        // create test wallets
        let mnemonics = [];
        for (let name of names) {
          let wallet = await that.createWallet({path: name, password: TestUtils.WALLET_PASSWORD});
          mnemonics.push(await wallet.getMnemonic());
          await that.closeWallet(wallet, true);
        }
        
        // open test wallets
        let wallets = [];
        for (let i = 0; i &lt; numTestWallets; i++) {
          let wallet = await that.openWallet({path: names[i], password: TestUtils.WALLET_PASSWORD});
          assert.equal(await wallet.getMnemonic(), mnemonics[i]);
          wallets.push(wallet);
        }
        
        // attempt to re-open already opened wallet
        try {
          await that.openWallet({path: names[numTestWallets - 1], password: TestUtils.WALLET_PASSWORD});
        } catch (e) {
          assert.equal(e.getCode(), -1);
        }
        
        // attempt to open non-existent
        try {
          await that.openWallet({path: "btc_integrity", password: TestUtils.WALLET_PASSWORD});
          throw new Error("Cannot open wallet which is already open");
        } catch (e) {
          assert(e instanceof MoneroError);
          assert.equal( e.getCode(), -1);  // -1 indicates wallet does not exist (or is open by another app)
        }
        
        // close wallets
        for (let wallet of wallets) await that.closeWallet(wallet);
      });
      
      if (testConfig.testNonRelays)
      it("Can indicate if multisig import is needed for correct balance information", async function() {
        assert.equal(await that.wallet.isMultisigImportNeeded(), false);
      });

      if (testConfig.testNonRelays)
      it("Can tag accounts and query accounts by tag", async function() {
        
        // get accounts
        let accounts = await that.wallet.getAccounts();
        assert(accounts.length >= 3, "Not enough accounts to test; run create account test");
        
        // tag some of the accounts
        let tag = new MoneroAccountTag("my_tag_" + GenUtils.getUUID(), "my tag label", [0, 1]);
        await that.wallet.tagAccounts(tag.getTag(), tag.getAccountIndices());
        
        // query accounts by tag
        let taggedAccounts = await that.wallet.getAccounts(undefined, tag.getTag());
        assert.equal(taggedAccounts.length, 2);
        assert.equal(taggedAccounts[0].getIndex(), 0);
        assert.equal(taggedAccounts[0].getTag(), tag.getTag());
        assert.equal(taggedAccounts[1].getIndex(), 1);
        assert.equal(taggedAccounts[1].getTag(), tag.getTag());

        // set tag label
        await that.wallet.setAccountTagLabel(tag.getTag(), tag.getLabel());
        
        // fetch tags and ensure new tag is contained
        let tags = await that.wallet.getAccountTags();
        assert(GenUtils.arrayContains(tags, tag));
        
        // re-tag an account
        let tag2 = new MoneroAccountTag("my_tag_" + GenUtils.getUUID(), "my tag label 2", [1]);
        await that.wallet.tagAccounts(tag2.getTag(), tag2.getAccountIndices());
        let taggedAccounts2 = await that.wallet.getAccounts(undefined, tag2.getTag())
        assert.equal(taggedAccounts2.length, 1);
        assert.equal(taggedAccounts2[0].getIndex(), 1);
        assert.equal(taggedAccounts2[0].getTag(), tag2.getTag());
        
        // re-query original tag which only applies to one account now
        taggedAccounts = await that.wallet.getAccounts(undefined, tag.getTag());
        assert.equal(taggedAccounts.length, 1);
        assert.equal(taggedAccounts[0].getIndex(), 0);
        assert.equal(taggedAccounts[0].getTag(), tag.getTag());
        
        // untag and query accounts
        await that.wallet.untagAccounts([0, 1]);
        assert.equal((await that.wallet.getAccountTags()).length, 0);
        try {
          await that.wallet.getAccounts(undefined, tag.getTag());
          fail("Should have thrown exception with unregistered tag");
        } catch (e) {
          assert.equal(e.getCode(), -1);
        }
        
        // test that non-existing tag returns no accounts
        try {
          await that.wallet.getAccounts(undefined, "non_existing_tag");
          fail("Should have thrown exception with unregistered tag");
        } catch (e) {
          assert.equal(e.getCode(), -1);
        }
      });
      
      if (testConfig.testNonRelays)
      it("Can fetch accounts and subaddresses without balance info because this is another RPC call", async function() {
        let accounts = await that.wallet.getAccounts(true, undefined, true);
        assert(accounts.length > 0);
        for (let account of accounts) {
          assert(account.getSubaddresses().length > 0);
          for (let subaddress of account.getSubaddresses()) {
            assert.equal(typeof subaddress.getAddress(), "string");
            assert(subaddress.getAddress().length > 0);
            assert(subaddress.getAccountIndex() >= 0);
            assert(subaddress.getIndex() >= 0);
            assert(subaddress.getLabel() === undefined || typeof subaddress.getLabel() === "string");
            if (typeof subaddress.getLabel() === "string") assert(subaddress.getLabel().length > 0);
            assert.equal(typeof subaddress.isUsed(), "boolean");
            assert.equal(subaddress.getNumUnspentOutputs(), undefined);
            assert.equal(subaddress.getBalance(), undefined);
            assert.equal(subaddress.getUnlockedBalance(), undefined);
          }
        }
      });
      
      if (testConfig.testNonRelays)
      it("Can rescan spent", async function() {
        await that.wallet.rescanSpent();
      });
      
      if (testConfig.testNonRelays)
      it("Can save the wallet file", async function() {
        await that.wallet.save();
      });
      
      if (testConfig.testNonRelays)
      it("Can close a wallet", async function() {
        
        // create a test wallet
        let path = GenUtils.getUUID();
        let wallet = await that.createWallet({path: path, password: TestUtils.WALLET_PASSWORD});
        await wallet.sync();
        assert((await wallet.getHeight()) > 1);
        
        // close the wallet
        await wallet.close();
        
        // attempt to interact with the wallet
        try {
          await wallet.getHeight();
        } catch (e) {
          assert.equal(e.getCode(), -13);
          assert.equal(e.message, "No wallet file");
        }
        try {
          await wallet.getMnemonic();
        } catch (e) {
          assert.equal(e.getCode(), -13);
          assert.equal(e.message, "No wallet file");
        }
        try {
          await wallet.sync();
        } catch (e) {
          assert.equal(e.getCode(), -13);
          assert.equal(e.message, "No wallet file");
        }
        
        // re-open the wallet
        await wallet.openWallet(path, TestUtils.WALLET_PASSWORD);
        await wallet.sync();
        assert.equal(await wallet.getHeight(), await that.daemon.getHeight());
        
        // close the wallet
        await that.closeWallet(wallet, true);
      });
      
      if (false &amp;&amp; testConfig.testNonRelays)  // disabled so server not actually stopped
      it("Can stop the RPC server", async function() {
        await that.wallet.stop();
      });
    });
  }
}

module.exports = TestMoneroWalletRpc;

function testAddressBookEntry(entry) {
  assert(entry.getIndex() >= 0);
  assert(entry.getAddress());
  assert(entry.getDescription());
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ConnectionType.html">ConnectionType</a></li><li><a href="GenUtils.html">GenUtils</a></li><li><a href="HttpClient.html">HttpClient</a></li><li><a href="LibraryUtils.html">LibraryUtils</a></li><li><a href="MoneroAccount.html">MoneroAccount</a></li><li><a href="MoneroAccountTag.html">MoneroAccountTag</a></li><li><a href="MoneroAddressBookEntry.html">MoneroAddressBookEntry</a></li><li><a href="MoneroAltChain.html">MoneroAltChain</a></li><li><a href="MoneroBan.html">MoneroBan</a></li><li><a href="MoneroBlock.html">MoneroBlock</a></li><li><a href="MoneroBlockHeader.html">MoneroBlockHeader</a></li><li><a href="MoneroBlockTemplate.html">MoneroBlockTemplate</a></li><li><a href="MoneroCheck.html">MoneroCheck</a></li><li><a href="MoneroCheckReserve.html">MoneroCheckReserve</a></li><li><a href="MoneroCheckTx.html">MoneroCheckTx</a></li><li><a href="MoneroDaemonConnection.html">MoneroDaemonConnection</a></li><li><a href="MoneroDaemonConnectionSpan.html">MoneroDaemonConnectionSpan</a></li><li><a href="MoneroDaemonInfo.html">MoneroDaemonInfo</a></li><li><a href="MoneroDaemonPeer.html">MoneroDaemonPeer</a></li><li><a href="MoneroDaemonRpc.html">MoneroDaemonRpc</a></li><li><a href="MoneroDaemonSyncInfo.html">MoneroDaemonSyncInfo</a></li><li><a href="MoneroDaemonUpdateCheckResult.html">MoneroDaemonUpdateCheckResult</a></li><li><a href="MoneroDaemonUpdateDownloadResult.html">MoneroDaemonUpdateDownloadResult</a></li><li><a href="MoneroDestination.html">MoneroDestination</a></li><li><a href="MoneroError.html">MoneroError</a></li><li><a href="MoneroHardForkInfo.html">MoneroHardForkInfo</a></li><li><a href="MoneroIncomingTransfer.html">MoneroIncomingTransfer</a></li><li><a href="MoneroIntegratedAddress.html">MoneroIntegratedAddress</a></li><li><a href="MoneroKeyImage.html">MoneroKeyImage</a></li><li><a href="MoneroKeyImageImportResult.html">MoneroKeyImageImportResult</a></li><li><a href="MoneroKeyImageSpentStatus.html">MoneroKeyImageSpentStatus</a></li><li><a href="MoneroMessageSignatureResult.html">MoneroMessageSignatureResult</a></li><li><a href="MoneroMessageSignatureType.html">MoneroMessageSignatureType</a></li><li><a href="MoneroMinerTxSum.html">MoneroMinerTxSum</a></li><li><a href="MoneroMiningStatus.html">MoneroMiningStatus</a></li><li><a href="MoneroMultisigInfo.html">MoneroMultisigInfo</a></li><li><a href="MoneroMultisigInitResult.html">MoneroMultisigInitResult</a></li><li><a href="MoneroMultisigSignResult.html">MoneroMultisigSignResult</a></li><li><a href="MoneroNetworkType.html">MoneroNetworkType</a></li><li><a href="MoneroOutgoingTransfer.html">MoneroOutgoingTransfer</a></li><li><a href="MoneroOutput.html">MoneroOutput</a></li><li><a href="MoneroOutputHistogramEntry.html">MoneroOutputHistogramEntry</a></li><li><a href="MoneroOutputQuery.html">MoneroOutputQuery</a></li><li><a href="MoneroOutputWallet.html">MoneroOutputWallet</a></li><li><a href="MoneroRpcConnection.html">MoneroRpcConnection</a></li><li><a href="MoneroRpcError.html">MoneroRpcError</a></li><li><a href="MoneroSubaddress.html">MoneroSubaddress</a></li><li><a href="MoneroSubmitTxResult.html">MoneroSubmitTxResult</a></li><li><a href="MoneroSyncResult.html">MoneroSyncResult</a></li><li><a href="MoneroTransfer.html">MoneroTransfer</a></li><li><a href="MoneroTransferQuery.html">MoneroTransferQuery</a></li><li><a href="MoneroTx.html">MoneroTx</a></li><li><a href="MoneroTxConfig.html">MoneroTxConfig</a></li><li><a href="MoneroTxPoolStats.html">MoneroTxPoolStats</a></li><li><a href="MoneroTxPriority.html">MoneroTxPriority</a></li><li><a href="MoneroTxQuery.html">MoneroTxQuery</a></li><li><a href="MoneroTxSet.html">MoneroTxSet</a></li><li><a href="MoneroTxWallet.html">MoneroTxWallet</a></li><li><a href="MoneroUtils.html">MoneroUtils</a></li><li><a href="MoneroVersion.html">MoneroVersion</a></li><li><a href="MoneroWalletConfig.html">MoneroWalletConfig</a></li><li><a href="MoneroWalletFull.html">MoneroWalletFull</a></li><li><a href="MoneroWalletKeys.html">MoneroWalletKeys</a></li><li><a href="MoneroWalletListener.html">MoneroWalletListener</a></li><li><a href="MoneroWalletRpc.html">MoneroWalletRpc</a></li><li><a href="ReceivedOutputNotificationTester.html">ReceivedOutputNotificationTester</a></li><li><a href="RunWalletRpcTestServers.html">RunWalletRpcTestServers</a></li><li><a href="SslOptions.html">SslOptions</a></li><li><a href="StartMining.html">StartMining</a></li><li><a href="SyncProgressTester.html">SyncProgressTester</a></li><li><a href="TestDeveloperGuide.html">TestDeveloperGuide</a></li><li><a href="TestMoneroDaemonRpc.html">TestMoneroDaemonRpc</a></li><li><a href="TestMoneroUtils.html">TestMoneroUtils</a></li><li><a href="TestMoneroWalletCommon.html">TestMoneroWalletCommon</a></li><li><a href="TestMoneroWalletFull.html">TestMoneroWalletFull</a></li><li><a href="TestMoneroWalletKeys.html">TestMoneroWalletKeys</a></li><li><a href="TestMoneroWalletRpc.html">TestMoneroWalletRpc</a></li><li><a href="TestSampleCode.html">TestSampleCode</a></li><li><a href="TestUtils.html">TestUtils</a></li><li><a href="ThreadPool.html">ThreadPool</a></li><li><a href="WalletEqualityUtils.html">WalletEqualityUtils</a></li><li><a href="WalletNotificationCollector.html">WalletNotificationCollector</a></li><li><a href="WalletSyncPrinter.html">WalletSyncPrinter</a></li><li><a href="WalletSyncTester.html">WalletSyncTester</a></li><li><a href="WalletTxTracker.html">WalletTxTracker</a></li></ul><h3>Interfaces</h3><ul><li><a href="MoneroDaemon.html">MoneroDaemon</a></li><li><a href="MoneroWallet.html">MoneroWallet</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getRandomTransactions">getRandomTransactions</a></li><li><a href="global.html#runTests">runTests</a></li><li><a href="global.html#testGetTxsStructure">testGetTxsStructure</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Tue Aug 17 2021 11:42:14 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
